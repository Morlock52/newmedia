name: Deploy to Environments

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
          - development
      version:
        description: 'Version to deploy (e.g., v1.2.3 or latest)'
        required: false
        default: 'latest'
      strategy:
        description: 'Deployment strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary
      canary_percentage:
        description: 'Canary deployment percentage (if canary strategy)'
        required: false
        default: '10'
  
  repository_dispatch:
    types: [new-release]

permissions:
  contents: read
  deployments: write
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository_owner }}/newmedia

jobs:
  # =================
  # PRE-DEPLOYMENT CHECKS
  # =================
  pre-deployment:
    runs-on: ubuntu-latest
    outputs:
      can_deploy: ${{ steps.checks.outputs.can_deploy }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            VERSION="${{ github.event.client_payload.version }}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Run pre-deployment checks
        id: checks
        run: |
          CAN_DEPLOY=true
          
          # Check if images exist
          for service in ai-ml-nexus ar-vr-media voice-ai-system web3-blockchain quantum-security; do
            if ! docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${service}:${{ steps.version.outputs.version }} > /dev/null 2>&1; then
              echo "Error: Image not found for ${service}"
              CAN_DEPLOY=false
            fi
          done
          
          echo "can_deploy=$CAN_DEPLOY" >> $GITHUB_OUTPUT

      - name: Check deployment window
        if: github.event.inputs.environment == 'production'
        run: |
          # Check if current time is within deployment window
          HOUR=$(date +%H)
          DAY=$(date +%u)
          
          # Allow deployments only on weekdays 9-17 UTC
          if [[ $DAY -gt 5 ]] || [[ $HOUR -lt 9 ]] || [[ $HOUR -gt 17 ]]; then
            echo "âš ï¸  WARNING: Deploying outside of normal deployment window"
            echo "Current time: $(date)"
            echo "Deployment windows: Weekdays 9:00-17:00 UTC"
          fi

  # =================
  # STAGING DEPLOYMENT
  # =================
  deploy-staging:
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: |
      needs.pre-deployment.outputs.can_deploy == 'true' && 
      (github.event.inputs.environment == 'staging' || github.event.inputs.environment == 'development')
    environment:
      name: ${{ github.event.inputs.environment }}
      url: https://${{ github.event.inputs.environment }}.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}

      - name: Deploy using Helm
        run: |
          helm upgrade --install newmedia-${{ github.event.inputs.environment }} \
            ./charts/newmedia \
            --namespace ${{ github.event.inputs.environment }} \
            --create-namespace \
            --set global.imageTag=${{ needs.pre-deployment.outputs.version }} \
            --set global.environment=${{ github.event.inputs.environment }} \
            --set-file global.secrets=${{ secrets.ENVIRONMENT_SECRETS }} \
            --wait \
            --timeout 10m

      - name: Run smoke tests
        run: |
          # Wait for deployments to be ready
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/instance=newmedia-${{ github.event.inputs.environment }} \
            -n ${{ github.event.inputs.environment }} \
            --timeout=300s
          
          # Run smoke tests
          kubectl run smoke-test --rm -i --restart=Never \
            --image=curlimages/curl:latest \
            -- sh -c "
              curl -f http://ai-ml-nexus.${{ github.event.inputs.environment }}.svc.cluster.local/health &&
              curl -f http://ar-vr-media.${{ github.event.inputs.environment }}.svc.cluster.local/health &&
              curl -f http://voice-ai-system.${{ github.event.inputs.environment }}.svc.cluster.local/health
            "

      - name: Update deployment status
        if: always()
        uses: chrnorm/deployment-status@v2
        with:
          token: ${{ github.token }}
          environment-url: https://${{ github.event.inputs.environment }}.example.com
          state: ${{ job.status }}
          deployment-id: ${{ steps.deployment.outputs.deployment_id }}

  # =================
  # PRODUCTION DEPLOYMENT
  # =================
  deploy-production:
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: |
      needs.pre-deployment.outputs.can_deploy == 'true' && 
      github.event.inputs.environment == 'production'
    environment:
      name: production
      url: https://example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PROD_AWS_ROLE_ARN }}
          aws-region: ${{ secrets.PROD_AWS_REGION }}

      - name: Backup current deployment
        run: |
          # Create backup of current deployment
          kubectl create job backup-$(date +%s) \
            --from=cronjob/backup-job \
            -n production
          
          # Export current deployment manifests
          kubectl get all,configmap,secret,ingress \
            -n production \
            -o yaml > backup-manifests-$(date +%Y%m%d-%H%M%S).yaml

      - name: Deploy using strategy
        run: |
          case "${{ github.event.inputs.strategy }}" in
            "rolling")
              ./scripts/deploy-rolling.sh \
                --environment production \
                --version ${{ needs.pre-deployment.outputs.version }}
              ;;
            "blue-green")
              ./scripts/deploy-blue-green.sh \
                --environment production \
                --version ${{ needs.pre-deployment.outputs.version }}
              ;;
            "canary")
              ./scripts/deploy-canary.sh \
                --environment production \
                --version ${{ needs.pre-deployment.outputs.version }} \
                --percentage ${{ github.event.inputs.canary_percentage }}
              ;;
          esac

      - name: Run production tests
        run: |
          # Run comprehensive test suite
          ./scripts/run-production-tests.sh \
            --environment production \
            --version ${{ needs.pre-deployment.outputs.version }}

      - name: Monitor deployment
        run: |
          # Monitor key metrics for 10 minutes
          ./scripts/monitor-deployment.sh \
            --duration 600 \
            --threshold-error-rate 1 \
            --threshold-response-time 1000

  # =================
  # ROLLBACK CAPABILITY
  # =================
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: failure()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Automatic rollback
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          
          echo "ðŸ”„ Initiating automatic rollback for $ENVIRONMENT"
          
          # Get previous stable version
          PREVIOUS_VERSION=$(helm history newmedia-$ENVIRONMENT -n $ENVIRONMENT | tail -2 | head -1 | awk '{print $1}')
          
          # Rollback to previous version
          helm rollback newmedia-$ENVIRONMENT $PREVIOUS_VERSION \
            -n $ENVIRONMENT \
            --wait \
            --timeout 10m
          
          # Verify rollback
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/instance=newmedia-$ENVIRONMENT \
            -n $ENVIRONMENT \
            --timeout=300s

      - name: Notify rollback
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "âš ï¸ Deployment Rollback Initiated",
              "attachments": [{
                "color": "warning",
                "fields": [
                  {"title": "Environment", "value": "${{ github.event.inputs.environment }}", "short": true},
                  {"title": "Failed Version", "value": "${{ needs.pre-deployment.outputs.version }}", "short": true},
                  {"title": "Status", "value": "Rolled back to previous stable version", "short": false}
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # =================
  # POST-DEPLOYMENT
  # =================
  post-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: success()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Update deployment tracking
        run: |
          # Record deployment in tracking system
          cat > deployment-record.json << EOF
          {
            "environment": "${{ github.event.inputs.environment }}",
            "version": "${{ needs.pre-deployment.outputs.version }}",
            "strategy": "${{ github.event.inputs.strategy }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployer": "${{ github.actor }}",
            "status": "success"
          }
          EOF

      - name: Trigger monitoring alerts
        run: |
          # Configure enhanced monitoring for new deployment
          curl -X POST ${{ secrets.MONITORING_WEBHOOK }} \
            -H "Content-Type: application/json" \
            -d '{
              "deployment": {
                "environment": "${{ github.event.inputs.environment }}",
                "version": "${{ needs.pre-deployment.outputs.version }}",
                "enable_enhanced_monitoring": true,
                "duration_hours": 24
              }
            }'

      - name: Update documentation
        run: |
          # Update deployment documentation
          echo "| $(date -u +%Y-%m-%d) | ${{ github.event.inputs.environment }} | ${{ needs.pre-deployment.outputs.version }} | ${{ github.event.inputs.strategy }} | ${{ github.actor }} | Success |" >> docs/deployment-history.md

      - name: Notify success
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              "text": "âœ… Deployment Successful!",
              "attachments": [{
                "color": "good",
                "fields": [
                  {"title": "Environment", "value": "${{ github.event.inputs.environment }}", "short": true},
                  {"title": "Version", "value": "${{ needs.pre-deployment.outputs.version }}", "short": true},
                  {"title": "Strategy", "value": "${{ github.event.inputs.strategy }}", "short": true},
                  {"title": "Deployed by", "value": "${{ github.actor }}", "short": true},
                  {"title": "URL", "value": "https://${{ github.event.inputs.environment == 'production' && 'example.com' || github.event.inputs.environment + '.example.com' }}"}
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}